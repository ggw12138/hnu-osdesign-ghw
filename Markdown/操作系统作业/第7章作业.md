# 第七章作业 智能1801 古浩为

## 第一题

1. 满足死锁有4个必要条件。
   1. 互斥：至少有一个资源必须处于非共享模式，即以此只有一个进程使用。如果另一进程申请该资源，那么申请进程必须等到该资源被释放为止。

   2. 占有并等待：一个进程必须占有至少一个资源，并等待另一资源，而该资源被其他进程所占有。

   3. 非抢占：资源不能被抢占，即资源只能在进程完成任务后自动释放。

   4. 循环等待：有一组等待进程{$P_0,P_1,...,P_n$},后一个等待资源为前一个所拥有，最后一个等待资源为第一个所拥有。

   5. 对应图中的实例：

      1. 每个路口只能在一个时间点通过一辆车。
      2. 每个路口每次只能过一辆车，其他车辆不允许通过。
      3. 每一辆车完全通过路口后其他车辆才能通过该路口。
      4. 左上角的大货车在等待他前面的灰色小轿车通过；左上角灰色小轿车在等待他前面的蓝色小轿车通过；左下角的下行方向的最下面的灰色小轿车在等待他面前的灰色小轿车通过；左下角右行方向的灰色小轿车在等待他前面的蓝色大货车。如此往复。

2. 设计规则避免死锁

    所有路口都设置红绿灯让纵向先行一段时间，然后等待相同的时间让横向车辆行驶。

## 第二题

题目：考虑如下系统：该系统包含 3 个进程，共享同一类型的资源 4 个，每一个进程最多需要 2 个该类型的资源，试说明为什么该系统不会发生死锁。

**解答**：我觉得是因为只有3个进程，而可用的同一类型的资源有4个，每个进程最多需要两个该类型的资源，假设3个进程都需要两个该类型的资源，4个资源分给3个人总有一个人能分到两个资源，那这一个人就可以顺利完成任务并释放资源，他破坏了占有并等待这个必要条件，所以避免死锁。

## 第三题

题目：现有单实例资源系统：进程 P1 占有资源 R2，请求资源 R1；进程 P2 占有资源 R1，请求资源 R3 R4 R5；进程 P3 占有资源 R4，请求资源 R5；进程 P4 占有资源 R5，请求资源 R2；进程 P5 占有资源 R3，请求资源 R1。

1. 图：![资源分配图和资源等待图](D:/VSCode/code/Markdown/图片/资源分配图和资源等待图.jpg)

2. 存在死锁，因为每个资源都只有单个实例，而资源分配图里面出现了环，就意味着会发生死锁。这个环是$P_1-R_1-P_2-R_4-P_3-R_5-P_4-R_2-P_1$,还有环$P_2-R_3-P_5-R_1-P_2$,$P_2-R_3-P_5-R_1-P_2$.

## 第四题

1. NEED=MAX-ALLOCATION
   0 0 0 0
   0 7 5 0
   1 0 0 2
   0 0 2 0
   0 6 4 2

2. 我们可以测试一下，能不能计算出一个安全序列。从P0开始，
    对P0，给，然后收回，Available={1,5,3,2}
    对P1，不给
    对P2，给，然后收回，Available={2,8,8,6}
    对P3，给，然后收回，Available={2,14,11,8}
    对P4，给，然后收回，Available={2,14,12,12}
    对P1，给，然后收回，Available={3,14,12,12}
    最终，我们可以得到一个安全序列{P0,P2,P3,P4,P1}
    所以安全

3. 矩阵
    |allocation  |     need     |   available|
    |:--:|:-:|:-:|
    |   0 0 1 2     |    0 0 0 0   |   2 1 0 0|
    |   0 4 2 0     |    1 3 3 0    ||
    |   1 3 5 4     |    1 0 0 2    ||
    |   0 6 3 2     |    0 0 2 0    ||
    |   0 0 1 4     |    0 6 4 2    ||
    对P0，给，然后收回，Available={2,1,1,2}
    对P1，不给
    对P2，给，然后收回，Available={3,4,6,6}
    对P3，给，然后收回，Available={3,10,9,8}
    对P4，不给
    对P1，给，然后收回，Available={3,14,11,8}
    对P4，给，然后收回，Avialable={3,14,12,12}
    最终，我们可以得到一个安全序列{P0,P2,P3,P1,P4}